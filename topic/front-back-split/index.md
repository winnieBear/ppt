# 前后端分离

## why

### google、facebook 不存在前后端分离，都是全栈，任何高级工程师都必须了解从浏览器到服务器全部过程

### 前端需要处理的问题的复杂性日益膨胀，导致需要专业的前端人员

* 端：pc 浏览器、手机浏览器、混合 App 的 webview、X5 内核（手 Q webview，微信公众号、QQ 浏览器）、微信小程序、支付宝小程序、PWA、...
* 知识点：

  * CSS：LESS、SASS、Stylus、PostCSS、...
  * 模块化：Common JS、AMD、CMD、ES6 模块
  * 构建工具：grunt、gulp、fis、npm srcipt、browserify、webpack、rollup、Parcel、...
  * 框架：jQuery、angular、backbone、React、Vue、RN、Weex、...
  * 其他：webassembly、nodejs、ES7、游戏引擎、图表框架、...

### 国内特殊国情导致的兼容性

* 从业人员平均水平相对太低，每一个职位只能做特定的事，前后端互相依赖，导致开发效率较低
* 操作系统 × 机型 × 端

## 业界现状

* Node.js 做中间层的服务端渲染方案
* Vue/React/Angular 等框架为主的浏览器端渲染方案
* Vue/React SSR 服务端渲染方案
* 基于 FIS3 的(PHP/JAVA/其他后端语言)后端渲染方案

## 为什么没选用 Node.js 做中间层的服务端渲染方案

* 技术人员的现状，缺少有后端开发经验的 Node.js 开发人员
* 缺少 Node.js web 服务 开发、部署、运维经验
* 前端需要一个人来负责 Node 服务，但不一定能达到后端的技术水准

## 为什么没选用Vue/React SSR 服务端渲染方案

## 平台前后端分离方案

### 基于 Vue 的浏览器渲染方案

#### 优点

* 前后端通过接口通信，前端负责展现和交互，后端负责业务逻辑和数据
* 切换页面时，前端只需要请求数据，不用返回除了数据之外的html、css等，性能较好
* 前后端可以并行开发，不再互相依赖；可以单独对接口和前端交互进行测试

#### 缺点

* 不能满足 SEO 需求，SSR 方案依赖 Node.js 提供 web 服务，以及方案的有待进一步成熟
* 到家的现状：每一个页面都是 SPA，静态资源不能充分利用；
* 首屏加载时间过长
* 多页面时所有页面的切换和逻辑都在前端控制，前端代码复杂度高，性能要求高，对前端人员要求较高

### 基于 FIS3 的 jello 方案

#### 优点

* 前后端通过数据约定，前端写 Velocity 模板，负责展现和交互，后端负责业务逻辑和数据
* 前后端约定好数据之后，可以并行开发，不再互相依赖；可以单独对接口和前端交互进行测试
* 支持 SEO
* 页面是服务端渲染，前端可以控制首屏输出的内容，性能较好，减少 Node.js 中间层的多一次接口调用

#### 缺点

* jello 本身基本不再维护，需要自己熟悉 FIS3 的逻辑，自己能修改
* jello 前端构建配置繁琐
* 服务端渲染页面依赖的静态资源是动态生成，不便于定位问题
* 缺少了 vue，react 的光环和谈资，被认为是落后的开发模式

#### 平台的实践

* 基于 jello 进行定制插件开发，扬长避短
* 发挥 jello 对 velocity 模板的语法扩充（继承、组件、重载的特性）
* 基于页面使用的组件自动完成构建配置
* 舍弃服务端渲染页面依赖的静态资源是动态生成，而是变成构建时自动生成
* 更方便后端的接入

## 实践情况

* 到家 PC 官网，m 官网

### 使用介绍

### 模板的继承，重载

### 组件

### 根据构建条件自动对静态资源的合并，压缩，替换（css/js/imgage)

### 根据环境自动加载对应环境(dev/test/sandbox/prod)的静态资源链接，自动切换接口环境

### 修改完自动构建，刷新浏览器

### 部署和上线

### 存在的问题

* 缺少了 vue，react 的光环和谈资，被认为是落后的开发模式，人才吸引不够
* 虽然大部分时间可以独立部署模板，有的需求在部署时需要跟后端一块部署，预计Q1会改变
* 前端缺乏定位问题的能力，需要后端协助，需要多了解更多后端的知识
* 可能存在极少数开发时没问题，测试时发现的问题，需要添加对应的配置等
